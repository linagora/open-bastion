diff --git a/lemonldap-ng-manager/lib/Lemonldap/NG/Manager/Build/Attributes.pm b/lemonldap-ng-manager/lib/Lemonldap/NG/Manager/Build/Attributes.pm
index 2243c19e0..55f05ee84 100644
--- a/lemonldap-ng-manager/lib/Lemonldap/NG/Manager/Build/Attributes.pm
+++ b/lemonldap-ng-manager/lib/Lemonldap/NG/Manager/Build/Attributes.pm
@@ -1574,7 +1574,25 @@ sub attributes {
             test          => sub { return perlExpr(@_) },
             msgFail       => '__badExpression__',
             default       => { default => 1 },
-            documentation => 'Authorization rules per PAM server group',
+            documentation => 'Authorization rules per PAM server group (legacy, use SSH/Sudo rules)',
+        },
+        pamAccessSshRules => {
+            type          => 'keyTextContainer',
+            keyTest       => qr/^[\w\-]+$/,
+            keyMsgFail    => '__badPamServerGroupName__',
+            test          => sub { return perlExpr(@_) },
+            msgFail       => '__badExpression__',
+            default       => {},
+            documentation => 'SSH authorization rules per server group',
+        },
+        pamAccessSudoRules => {
+            type          => 'keyTextContainer',
+            keyTest       => qr/^[\w\-]+$/,
+            keyMsgFail    => '__badPamServerGroupName__',
+            test          => sub { return perlExpr(@_) },
+            msgFail       => '__badExpression__',
+            default       => {},
+            documentation => 'Sudo authorization rules per server group',
         },
         pamAccessRp => {
             type          => 'text',
@@ -1607,6 +1625,16 @@ sub attributes {
             default       => {},
             documentation => 'Exported variables for PAM user provisioning',
         },
+        pamAccessOfflineEnabled => {
+            type          => 'boolOrExpr',
+            default       => 0,
+            documentation => 'Enable offline mode for PAM authorization caching',
+        },
+        pamAccessOfflineTtl => {
+            type          => 'int',
+            default       => 86400,
+            documentation => 'Default offline authorization cache TTL (seconds)',
+        },
 
         # History
         failedLoginNumber => {
diff --git a/lemonldap-ng-manager/lib/Lemonldap/NG/Manager/Build/Tree.pm b/lemonldap-ng-manager/lib/Lemonldap/NG/Manager/Build/Tree.pm
index 1192b034d..531369a22 100644
--- a/lemonldap-ng-manager/lib/Lemonldap/NG/Manager/Build/Tree.pm
+++ b/lemonldap-ng-manager/lib/Lemonldap/NG/Manager/Build/Tree.pm
@@ -986,12 +986,22 @@ sub tree {
                                 'pamAccessActivation',
                                 'pamAccessTokenDuration',
                                 'pamAccessMaxDuration',
-                                'pamAccessServerGroups',
+                                {
+                                    title => 'pamAccessAuthzRules',
+                                    form  => 'simpleInputContainer',
+                                    nodes => [
+                                        'pamAccessServerGroups',
+                                        'pamAccessSshRules',
+                                        'pamAccessSudoRules',
+                                    ]
+                                },
                                 'pamAccessRp',
                                 'pamAccessHeartbeatInterval',
                                 'pamAccessInactiveThreshold',
                                 'pamAccessHeartbeatRequired',
                                 'pamAccessExportedVars',
+                                'pamAccessOfflineEnabled',
+                                'pamAccessOfflineTtl',
                             ]
                         },
                         {
diff --git a/lemonldap-ng-portal/lib/Lemonldap/NG/Portal/Plugins/PamAccess.pm b/lemonldap-ng-portal/lib/Lemonldap/NG/Portal/Plugins/PamAccess.pm
index 2de9d5c64..aee0bffb1 100644
--- a/lemonldap-ng-portal/lib/Lemonldap/NG/Portal/Plugins/PamAccess.pm
+++ b/lemonldap-ng-portal/lib/Lemonldap/NG/Portal/Plugins/PamAccess.pm
@@ -326,7 +326,9 @@ sub authorize {
     }
 
     # 5. Evaluate authorization rule based on server_group
-    my $authorized = $self->_checkPamRule( $req, $host, $service, $server_group );
+    my $result = $self->_checkPamRule( $req, $host, $service, $server_group );
+    my $authorized   = $result->{authorized};
+    my $sudo_allowed = $result->{sudo_allowed};
 
     # Get groups for response
     my $groups = $req->sessionInfo->{groups} || '';
@@ -335,7 +337,8 @@ sub authorize {
     $self->logger->info(
         "PAM authorize: user '$user' " .
         ($authorized ? 'granted' : 'denied') .
-        " access to host '$host'"
+        " access to host '$host'" .
+        ($authorized && $sudo_allowed ? ' (sudo allowed)' : '')
     );
 
     # Audit log for authorization result
@@ -350,6 +353,7 @@ sub authorize {
             server_group => $server_group,
             server_id    => $server_id,
             groups       => \@groupList,
+            sudo_allowed => $sudo_allowed,
         );
     }
     else {
@@ -367,20 +371,57 @@ sub authorize {
         );
     }
 
+    # Build response with permissions
+    my $response = {
+        authorized => $authorized ? JSON::true : JSON::false,
+        user       => $user,
+        groups     => \@groupList,
+    };
+
+    # Add permissions for authorized users
+    if ($authorized) {
+        $response->{permissions} = {
+            sudo_allowed => $sudo_allowed ? JSON::true : JSON::false,
+        };
+
+        # Add user attributes for NSS/cache (from exported vars)
+        my $exportedVars = $self->conf->{pamAccessExportedVars} || {};
+        for my $key ( keys %$exportedVars ) {
+            my $attr = $exportedVars->{$key};
+            my $value = $req->sessionInfo->{$attr};
+            if ( defined $value && $value ne '' ) {
+                $response->{$key} = $value;
+            }
+        }
+
+        # Check if offline mode is enabled for this user
+        my $offlineEnabled = $self->_evaluateOfflineMode($req);
+        if ($offlineEnabled) {
+            my $offlineTtl = $self->conf->{pamAccessOfflineTtl} || 86400;
+            $response->{offline} = {
+                enabled => JSON::true,
+                ttl     => $offlineTtl,
+            };
+            $self->logger->debug(
+                "PAM authorize: offline mode enabled for user '$user' (TTL: ${offlineTtl}s)"
+            );
+        }
+    }
+    else {
+        $response->{reason} = 'Access denied by rule';
+    }
+
     return $self->p->sendJSONresponse(
         $req,
-        {
-            authorized => $authorized ? JSON::true : JSON::false,
-            user       => $user,
-            groups     => \@groupList,
-            ( $authorized ? () : ( reason => 'Access denied by rule' ) ),
-        },
+        $response,
         code => 200
     );
 }
 
 # HELPER METHODS
 
+# Check PAM authorization rule for a specific service type
+# Returns: { authorized => 0|1, sudo_allowed => 0|1 }
 sub _checkPamRule {
     my ( $self, $req, $host, $service, $server_group ) = @_;
 
@@ -389,29 +430,99 @@ sub _checkPamRule {
     $req->sessionInfo->{_pamService}     = $service;
     $req->sessionInfo->{_pamServerGroup} = $server_group || 'default';
 
-    my $rules = $self->conf->{pamAccessServerGroups} || {};
+    my $result = {
+        authorized   => 0,
+        sudo_allowed => 0,
+    };
+
+    # Determine which rule set to use based on service type
+    my $ssh_authorized = $self->_evaluateRule(
+        $req, $server_group, 'ssh'
+    );
+
+    # For SSH service, check SSH rules
+    if ( $service eq 'sshd' || $service eq 'ssh' ) {
+        $result->{authorized} = $ssh_authorized;
+    }
+    # For sudo service, check both SSH (must be connected) and sudo rules
+    elsif ( $service eq 'sudo' ) {
+        # User must first be authorized for SSH
+        if ($ssh_authorized) {
+            $result->{authorized} = 1;
+            $result->{sudo_allowed} = $self->_evaluateRule(
+                $req, $server_group, 'sudo'
+            );
+        }
+    }
+    # For other services, fall back to legacy rules
+    else {
+        $result->{authorized} = $self->_evaluateRule(
+            $req, $server_group, 'legacy'
+        );
+    }
+
+    # Also compute sudo_allowed for SSH requests (for response)
+    if ( $service eq 'sshd' || $service eq 'ssh' ) {
+        $result->{sudo_allowed} = $self->_evaluateRule(
+            $req, $server_group, 'sudo'
+        );
+    }
+
+    return $result;
+}
+
+# Evaluate a specific rule type for a server group
+sub _evaluateRule {
+    my ( $self, $req, $server_group, $rule_type ) = @_;
+
+    $server_group ||= 'default';
+
+    # Select the appropriate rule set
+    my $rules;
+    if ( $rule_type eq 'ssh' ) {
+        $rules = $self->conf->{pamAccessSshRules} || {};
+        # Fallback to legacy rules if SSH rules not defined
+        if ( !%$rules ) {
+            $rules = $self->conf->{pamAccessServerGroups} || {};
+        }
+    }
+    elsif ( $rule_type eq 'sudo' ) {
+        $rules = $self->conf->{pamAccessSudoRules} || {};
+        # No fallback for sudo - if not defined, sudo is denied
+    }
+    else {
+        # Legacy mode
+        $rules = $self->conf->{pamAccessServerGroups} || {};
+    }
+
     my $rule;
 
     # 1. Look for rule matching the requested server_group
-    if ( $server_group && exists $rules->{$server_group} ) {
+    if ( exists $rules->{$server_group} ) {
         $rule = $rules->{$server_group};
-        $self->logger->debug("PAM authorize: using rule for group '$server_group'");
+        $self->logger->debug(
+            "PAM authorize: using $rule_type rule for group '$server_group'"
+        );
     }
     # 2. Fallback to 'default' group
     elsif ( exists $rules->{default} ) {
         $rule = $rules->{default};
-        $self->logger->debug("PAM authorize: server_group '$server_group' not found, using 'default' rule");
+        $self->logger->debug(
+            "PAM authorize: $rule_type rule for '$server_group' not found, using 'default'"
+        );
     }
-    # 3. No rule found -> deny access
+    # 3. No rule found -> deny
     else {
-        $self->logger->warn("PAM authorize: no rule found for group '$server_group' and no 'default' rule");
+        $self->logger->debug(
+            "PAM authorize: no $rule_type rule for '$server_group' or 'default'"
+        );
         return 0;
     }
 
     # Simple boolean
-    return $rule if $rule =~ /^[01]$/;
+    return $rule if defined $rule && $rule =~ /^[01]$/;
 
-    # Empty rule -> deny
+    # Empty or undefined rule -> deny
     return 0 unless defined $rule && $rule ne '';
 
     # Evaluate rule as expression
@@ -422,6 +533,26 @@ sub _checkPamRule {
     return $result ? 1 : 0;
 }
 
+# Evaluate if offline mode is enabled for this user
+sub _evaluateOfflineMode {
+    my ( $self, $req ) = @_;
+
+    my $rule = $self->conf->{pamAccessOfflineEnabled};
+
+    # Not configured or disabled
+    return 0 unless defined $rule && $rule ne '' && $rule ne '0';
+
+    # Simple boolean true
+    return 1 if $rule eq '1';
+
+    # Evaluate as expression
+    my $result = $self->p->HANDLER->buildSub(
+        $self->p->HANDLER->substitute($rule)
+    )->( $req, $req->sessionInfo );
+
+    return $result ? 1 : 0;
+}
+
 sub _unauthorizedResponse {
     my ( $self, $req, $message ) = @_;
     $message ||= 'Unauthorized';
