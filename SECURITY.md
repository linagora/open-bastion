# Security Architecture

This document describes the security measures implemented in the LemonLDAP::NG PAM module.

## Overview

The PAM module authenticates users against a LemonLDAP::NG portal using a secure token-based
protocol. Multiple layers of defense protect against various attack vectors.

## Authentication Flow

```
User -> PAM Module -> LLNG Portal (/pam/verify) -> Response
                   <- Single-use token consumed ->
```

1. User provides a one-time token generated by the LLNG portal
2. PAM module verifies token via `/pam/verify` endpoint
3. Token is consumed _(single-use)_ and cannot be replayed
4. Server returns user attributes and authorization status

## Transport Security

### TLS Configuration

| Setting | Default | Description |
|---------|---------|-------------|
| `min_tls_version` | 13 (TLS 1.3) | Minimum TLS version (12=1.2, 13=1.3) |
| `verify_ssl` | true | Verify server certificate |
| `ca_cert` | system | Custom CA certificate path |
| `cert_pin` | none | Certificate pin (sha256//base64 format) |

**Certificate Pinning**: When configured, the module validates the server's public key against
the pinned value, preventing MITM attacks even with compromised CAs.

```ini
# Example configuration
min_tls_version = 13
cert_pin = sha256//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
```

### Request Signing (Optional)

When `request_signing_secret` is configured, requests include:

- `X-Timestamp`: Unix timestamp _(server should reject if too old)_
- `X-Nonce`: Unique `timestamp_ms-uuid` format _(server should reject duplicates)_
- `X-Signature-256`: HMAC-SHA256 signature of the request

This provides defense-in-depth against request tampering, even if TLS is somehow compromised.

## Server Authentication

The PAM module authenticates to the LLNG server using:

| Setting | Description |
|---------|-------------|
| `server_token_file` | Path to file containing server bearer token |
| `server_group` | Server group name (default: "default") |
| `token_rotate_refresh` | Automatically rotate refresh tokens (default: true) |

The server token should be stored in a file with restricted permissions (0600) owned by root.

### OAuth2 Client Authentication

For OAuth2 token introspection and refresh operations, the module uses **JWT Client Assertion**
(RFC 7523) instead of HTTP Basic Authentication. This provides enhanced security:

- The `client_secret` is never transmitted over the network
- Each request includes a unique JWT signed with HMAC-SHA256
- JWT contains: `iss`, `sub`, `aud`, `exp`, `iat`, and unique `jti` (UUID v4)
- JWT validity is 5 minutes to prevent replay attacks

### Automatic Token Rotation

When `token_rotate_refresh = true` (default), the module automatically rotates the refresh token after each successful token refresh. This limits the window of opportunity if a token is compromised, as stolen tokens become invalid after the next legitimate use.

## Token Cache Security

### Encryption at Rest

When `cache_encrypted = true` _(default)_, cached tokens are encrypted using:

- **Algorithm**: AES-256-GCM _(authenticated encryption)_
- **Key Derivation**: PBKDF2-SHA256 with 100,000 iterations
- **Key Source**: Machine ID (`/etc/machine-id`) + cache username as salt
- **Authentication**: GCM tag prevents tampering

```
File format:
[Plaintext: "expires_at\n"][Magic: LLNGCACHE02][IV: 12 bytes][Tag: 16 bytes][Ciphertext]
```

The plaintext timestamp header allows quick expiration checks without decryption
_(performance optimization)_. However, the timestamp is **duplicated inside the encrypted payload**
for integrity verification. If an attacker modifies the plaintext header to extend cache validity,
the mismatch with the encrypted timestamp causes immediate rejection and cache file deletion.

### Cache Isolation

- Each user's cache is stored in a separate file
- File permissions: 0600 _(owner read/write only)_
- Directory permissions: 0700

### Cache Invalidation

When `cache_invalidate_on_logout = true` _(default)_:
- User's cache is cleared when their PAM session closes
- Prevents stale tokens from being reused

### Risk-Based TTL

| Service Type | Default TTL |
|--------------|-------------|
| Normal services | 300 seconds |
| High-risk services | 60 seconds |

Configure high-risk services via `high_risk_services` _(comma-separated)_.

## Rate Limiting

Protection against brute-force attacks:

| Setting | Default | Description |
|---------|---------|-------------|
| `rate_limit_enabled` | true | Enable rate limiting |
| `rate_limit_max_attempts` | 5 | Failures before lockout |
| `rate_limit_initial_lockout` | 30s | Initial lockout duration |
| `rate_limit_max_lockout` | 3600s | Maximum lockout duration |
| `rate_limit_backoff_mult` | 2.0 | Exponential backoff multiplier |

Lockout state is stored per-user in `rate_limit_state_dir`.

## Auto-Create User Security

When `create_user_enabled = true`, users can be automatically created on first login.

### Path Validation

All paths are validated before use:

**Shell Validation** (`approved_shells`):
- Must be in approved list _(default: common shells like /bin/bash, /bin/zsh)_
- Must be absolute path
- No path traversal sequences _(.., //)_
- No shell metacharacters

**Home Directory Validation** (`approved_home_prefixes`):
- Must start with approved prefix _(default: /home, /var/home)_
- Same safety checks as shell

**Skeleton Directory Validation**:
- Must be absolute path
- Must be owned by root
- No symlinks in path components
- No dangerous patterns

### UID Generation

- UIDs are generated deterministically from username hash
- Range: 10000-60000 _(configurable)_
- **Collision handling**: If UID exists, operation fails safely _(returns 0)_
- No fallback to random UIDs that could cause unpredictable behavior

### NSS Module Security

The NSS module (`libnss_llng.so`) provides user resolution:

- **Buffer overflow protection**: All string copies use bounds-checked `safe_strcpy()`
- **Server input validation**: Shell and home paths from server are validated against approved lists
- **UID range enforcement**: Server-provided UIDs must be within configured min_uid/max_uid range
- **Fail-safe**: Returns appropriate error codes on any failure; invalid paths fall back to defaults

### Direct /etc/passwd and /etc/shadow Manipulation

User accounts are created by directly writing to `/etc/passwd` and `/etc/shadow` rather than using
external tools like `useradd`. This design choice was made for:

**Advantages**:
- **Portability**: No dependency on `useradd` which may not exist or have different options across distributions
- **Atomicity**: Single-process control over file locking ensures consistent state
- **Predictability**: No external tool behavior variations or unexpected prompts

**Trade-offs**:
- PAM account creation hooks are not triggered _(this module IS the PAM hook)_
- SELinux contexts must be handled separately if required
- System audit logs only see file modifications, not semantic "user created" events

**Mitigations**:
- The module emits its own structured audit events when `audit_enabled = true`
- File operations use exclusive locks (`flock`) to prevent race conditions
- If `/etc/shadow` write fails after `/etc/passwd` succeeds, rollback is attempted via `userdel`
- TOCTOU protection: user existence is re-checked after acquiring locks

## Audit Logging

When `audit_enabled = true`:

| Setting | Default | Description |
|---------|---------|-------------|
| `audit_log_file` | none | JSON audit log file path |
| `audit_to_syslog` | true | Also emit to syslog |
| `audit_level` | 1 | 0=critical, 1=auth events, 2=all |

Audit events include:
- Authentication attempts _(success/failure)_
- Authorization decisions
- Rate limit triggers
- User creation events

## Webhook Notifications

For real-time security monitoring:

| Setting | Description |
|---------|-------------|
| `notify_enabled` | Enable webhooks |
| `notify_url` | Webhook endpoint URL |
| `notify_secret` | HMAC secret for webhook signatures |

## Configuration Security

### Secrets Management

| Setting | Default | Description |
|---------|---------|-------------|
| `secrets_encrypted` | true | Encrypt secrets at rest |
| `secrets_use_keyring` | true | Use kernel keyring |
| `secrets_keyring_name` | "pam_llng" | Keyring identifier |

### File Permissions

Recommended permissions:

| File | Permissions | Owner |
|------|-------------|-------|
| `/etc/pam_llng.conf` | 0600 | root |
| Server token file | 0600 | root |
| Cache directory | 0700 | root |
| Rate limit state dir | 0700 | root |

## Operational Security Considerations

### Debug Logging Warning

**CRITICAL: Never enable debug logging in production environments.**

When `log_level = debug`, the module may log sensitive information to syslog:

- SSH certificate metadata (key_id, serial, principals)
- Token validation details
- Authorization request parameters

**Risk**: If debug logs are captured by a log aggregator or accessed by unauthorized users,
this information could be used to:
- Identify infrastructure topology
- Track user movements across systems
- Correlate sessions for targeting

**Recommendation**:
- Use `log_level = warn` or `log_level = error` in production
- If debug logging is temporarily needed, ensure syslog access is restricted
- Rotate and purge logs containing debug output promptly

### Machine-ID Stability Requirement

The encryption key for cached tokens and secrets is derived from `/etc/machine-id`.

**Impact of machine-id change**:
- All cached tokens become unreadable (automatic re-authentication required)
- Encrypted secrets in the secret store become permanently unrecoverable
- Server enrollment tokens must be re-issued

**Scenarios causing machine-id change**:
- VM cloning without regenerating machine-id
- System reinstallation
- Container image reuse across hosts
- Some cloud provider instance recreation

**Recommendations**:
1. **Document machine-id stability** as a deployment requirement
2. **Before system migration**: Backup enrollment tokens or plan for re-enrollment
3. **VM cloning**: Always regenerate machine-id (`systemd-machine-id-setup`) and re-enroll
4. **Monitoring**: Alert on machine-id changes via configuration management

**Re-enrollment procedure after machine-id change**:
```bash
# 1. The old token file is now unusable - remove it
rm /etc/security/pam_llng.token

# 2. Re-run enrollment
llng-pam-enroll --portal https://auth.example.com --client-id pam-access
```

## Threat Mitigations

| Threat | Mitigation |
|--------|------------|
| Token replay | Single-use tokens, cache invalidation |
| MITM attacks | TLS 1.3, certificate pinning |
| Brute force | Rate limiting with exponential backoff |
| Cache tampering | AES-256-GCM authenticated encryption |
| Path injection | Strict path validation, approved lists |
| Buffer overflow | Bounds-checked string operations, snprintf with null-termination |
| UID collision | Fail-safe collision detection |
| Request tampering | Optional HMAC request signing with nonces |
| Memory exhaustion DoS | Response size limits (256KB), group limits (256 max) |
| Integer overflow | Input validation in base64 encoding, backoff calculations |
| Malformed JSON | Type validation for critical response fields |
| Client secret exposure | JWT Client Assertion (RFC 7523) - secret never transmitted |

## Security Reporting

To report security vulnerabilities, please email security@linagora.com with:

1. Description of the vulnerability
2. Steps to reproduce
3. Potential impact
4. Any suggested fixes

We aim to respond within 48 hours and will coordinate disclosure.
